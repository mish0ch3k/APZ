# Практична 1 (pr1)

## Опис
Цей скрипт на Bash шукає бібліотеки у `/usr/lib` і перевіряє, чи є в них функції `sin`, `cos` та `exp`. Він перебирає всі `.so` файли та перевіряє їх за допомогою `nm -D`.

## Як запустити
1. Клонуйте репозиторій:
   ```bash
   git clone https://github.com/mish0ch3k/APZ
   ```
2. Дайте файлу права на виконання:
   ```bash
   chmod +x find_functions.sh
   ```
3. Запустіть у терміналі:
   ```bash
   ./find_functions.sh
   ```

## Як це працює
- `LIB_DIR` – це папка, де шукаємо бібліотеки (за замовчуванням `/usr/lib`).
- `FUNCTIONS` – список функцій, які шукаємо (`sin`, `cos`, `exp`).
- Скрипт шукає всі `.so` файли в папці `LIB_DIR`.
- За допомогою `nm -D` перевіряє, чи є в них потрібні функції.
- Якщо знайдено, виводить щось типу:
  ```
  Lib /usr/lib/libm.so have func sin
  ```

## Вимоги
- Linux або WSL (Windows Subsystem for Linux)
- Утиліта `nm` (з пакету `binutils`)

## Як змінити цільову директорію для перевірки
Якщо потрібно перевіряти іншу папку, змініть `LIB_DIR`, наприклад:
```bash
LIB_DIR="/lib/x86_64-linux-gnu"
```


# Практична 2 (pr2)

## Опис

Ця практична містить приклади програм і дослідження архітектури виконуваних файлів, памʼяті процесу (stack, heap, data, bss, text), функції `mmap()` проти `malloc()`, і аналізу стеку за допомогою `gstack` та `gdb`.

## Як запустити

```bash
git clone https://github.com/mish0ch3k/APZ
cd APZ
gcc p21.c -o time_check
./time_check

gcc p23.c -o segments
./segments

gcc mmap.c -o test_mmap
./test_mmap
```
Файл p24 потрібно запускати окремо, потім відкрити інший термінал і виконати:
```bash
gcc p24.c -o trace
./trace    
gstack <PID>       # або
gdb -p <PID> -> bt
```

## Аналіз mmap vs malloc
-malloc.c — виділяє 10 МБ памʼяті через heap.

-mmap.c — виділяє ті ж 10 МБ, але напряму через mmap.

-За допомогою pmap <PID> можна побачити різницю:

-malloc → heap

-mmap → окремий регіон памʼяті


## Що досліджено
-Коли переповниться time_t на 32-біт і 64-біт системах

-Як змінюється виконуваний файл при використанні .bss vs .data

-Як ініціалізовані й неініціалізовані змінні потрапляють у різні сегменти

-Розташування стеку, купи, глобальних даних у процесі

-Як mmap() впливає на структуру памʼяті в порівнянні з malloc()

-Аналіз стеку: gstack, gdb, pause+backtrace

## Вимоги
Linux або WSL
GCC
gdb, gstack або pstack
binutils (для nm, size, objdump)


# Практична 3 (pr3)

## 3.1 
Запустіть Docker-контейнер і поекспериментуйте з максимальним лімітом ресурсів відкритих файлів. Для цього виконайте команди у вказаному порядку: $ ulimit -n $ ulimit -aS | grep "open files" $ ulimit -aH | grep "open files" $ ulimit -n 3000 $ ulimit -aS | grep "open files" $ ulimit -aH | grep "open files" $ ulimit -n 3001 $ ulimit -n 2000 $ ulimit -n $ ulimit -aS | grep "open files" $ ulimit -aH | grep "open files" $ ulimit -n 3000

![alt text](image.png)

## 3.2
![alt text](image-1.png)

## 3.3 
Напишіть програму, що імітує кидання шестигранного кубика. Імітуйте кидки, результати записуйте у файл, для якого попередньо встановлено обмеження на його максимальний розмір (max file size). Коректно обробіть ситуацію перевищення ліміту.
![alt text](image-5.png)

## 3.4
Напишіть програму, що імітує лотерею, вибираючи 7 різних цілих чисел у діапазоні від 1 до 49 і ще 6 з 36. Встановіть обмеження на час ЦП (max CPU time) і генеруйте результати вибору чисел (7 із 49, 6 із 36). Обробіть ситуацію, коли ліміт ресурсу вичерпано.
![alt text](image-4.png)

## 3.5 
Напишіть програму для копіювання одного іменованого файлу в інший. Імена файлів передаються у вигляді аргументів.
Перший файл:
![alt text](image-8.png)
Виконуємо програму:
![alt text](image-6.png)
Другий файл:
![alt text](image-7.png)

## 3.6 
Напишіть програму, що демонструє використання обмеження (max stack segment size). Підказка: рекурсивна програма активно використовує стек
![alt text](image-9.png)
![alt text](image-10.png)

## 3.7
Встановити обмеження на кількість відкритих сокетів (ulimit -n) та запустити серверну програму.
bash ```ulimit -n 100```
![alt text](image-11.png)

```
for i in {1..150}; do
  (sleep 10 | telnet 127.0.0.1 8080) &
done
```

![alt text](image-12.png)

# Практична 4 (pr4)
## Завдання 4.1 (task1.c)
Скільки пам’яті може виділити malloc(3) за один виклик?
Параметр malloc(3) є цілим числом типу даних size_t, тому логічно максимальне число, яке можна передати як параметр malloc(3), — це максимальне значення size_t на платформі (sizeof(size_t)). У 64-бітній Linux size_t становить 8 байтів, тобто 8 * 8 = 64 біти. Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик malloc(3), дорівнює 2^64. Спробуйте запустити код на x86_64 та x86. Чому теоретично максимальний обсяг складає 8 ексабайт, а не 16?
## Завдання 4.2 (task2.c)
Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.
## Завдання 4.3 (task3.c)
Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми.
## Завдання 4.4 (task4.c)
Чи є помилки у такому коді?
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... <використання 'ptr'> ...]
    free(ptr);
}
Напишіть тестовий випадок, який продемонструє проблему та правильний варіант коду.
## Завдання 4.5 (task5.c)
Що станеться, якщо realloc(3) не зможе виділити пам’ять? Напишіть тестовий випадок, що демонструє цей сценарій.
## Завдання 4.6 (task6.c)
Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок.
## Завдання 4.7 (task7.c)
Перепишіть наступний код, використовуючи reallocarray(3):
struct sbar *ptr, *newptr;
ptr = calloc(1000, sizeof(struct sbar));
newptr = realloc(ptr, 500*sizeof(struct sbar));

Порівняйте результати виконання з використанням ltrace.

## Завдання 4.8 (task8.c)
2 Напишіть програму для імітації витоку пам’яті та засічіть її за допомогою valgrind.
![alt text](image-13.png)

Використання:
```gcc -g -o task8 task8.c```
```sudo apt  install valgrind```
```valgrind --leak-check=full ./task8```