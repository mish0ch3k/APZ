# Практична 1 (pr1)

## Опис
Цей скрипт на Bash шукає бібліотеки у `/usr/lib` і перевіряє, чи є в них функції `sin`, `cos` та `exp`. Він перебирає всі `.so` файли та перевіряє їх за допомогою `nm -D`.

## Як запустити
1. Клонуйте репозиторій:
   ```bash
   git clone https://github.com/mish0ch3k/APZ
   ```
2. Дайте файлу права на виконання:
   ```bash
   chmod +x find_functions.sh
   ```
3. Запустіть у терміналі:
   ```bash
   ./find_functions.sh
   ```

## Як це працює
- `LIB_DIR` – це папка, де шукаємо бібліотеки (за замовчуванням `/usr/lib`).
- `FUNCTIONS` – список функцій, які шукаємо (`sin`, `cos`, `exp`).
- Скрипт шукає всі `.so` файли в папці `LIB_DIR`.
- За допомогою `nm -D` перевіряє, чи є в них потрібні функції.
- Якщо знайдено, виводить щось типу:
  ```
  Lib /usr/lib/libm.so have func sin
  ```

## Вимоги
- Linux або WSL (Windows Subsystem for Linux)
- Утиліта `nm` (з пакету `binutils`)

## Як змінити цільову директорію для перевірки
Якщо потрібно перевіряти іншу папку, змініть `LIB_DIR`, наприклад:
```bash
LIB_DIR="/lib/x86_64-linux-gnu"
```


# Практична 2 (pr2)

## Опис

Ця практична містить приклади програм і дослідження архітектури виконуваних файлів, памʼяті процесу (stack, heap, data, bss, text), функції `mmap()` проти `malloc()`, і аналізу стеку за допомогою `gstack` та `gdb`.

## Як запустити

```bash
git clone https://github.com/mish0ch3k/APZ
cd APZ
gcc p21.c -o time_check
./time_check

gcc p23.c -o segments
./segments

gcc mmap.c -o test_mmap
./test_mmap
```
Файл p24 потрібно запускати окремо, потім відкрити інший термінал і виконати:
```bash
gcc p24.c -o trace
./trace    
gstack <PID>       # або
gdb -p <PID> -> bt
```

## Аналіз mmap vs malloc
-malloc.c — виділяє 10 МБ памʼяті через heap.

-mmap.c — виділяє ті ж 10 МБ, але напряму через mmap.

-За допомогою pmap <PID> можна побачити різницю:

-malloc → heap

-mmap → окремий регіон памʼяті


## Що досліджено
-Коли переповниться time_t на 32-біт і 64-біт системах

-Як змінюється виконуваний файл при використанні .bss vs .data

-Як ініціалізовані й неініціалізовані змінні потрапляють у різні сегменти

-Розташування стеку, купи, глобальних даних у процесі

-Як mmap() впливає на структуру памʼяті в порівнянні з malloc()

-Аналіз стеку: gstack, gdb, pause+backtrace

## Вимоги
Linux або WSL
GCC
gdb, gstack або pstack
binutils (для nm, size, objdump)


# Практична 3 (pr3)

## 3.1 
Запустіть Docker-контейнер і поекспериментуйте з максимальним лімітом ресурсів відкритих файлів. Для цього виконайте команди у вказаному порядку: $ ulimit -n $ ulimit -aS | grep "open files" $ ulimit -aH | grep "open files" $ ulimit -n 3000 $ ulimit -aS | grep "open files" $ ulimit -aH | grep "open files" $ ulimit -n 3001 $ ulimit -n 2000 $ ulimit -n $ ulimit -aS | grep "open files" $ ulimit -aH | grep "open files" $ ulimit -n 3000

![alt text](.assets/image.png)

## 3.2
![alt text](.assets/image-1.png)

## 3.3 
Напишіть програму, що імітує кидання шестигранного кубика. Імітуйте кидки, результати записуйте у файл, для якого попередньо встановлено обмеження на його максимальний розмір (max file size). Коректно обробіть ситуацію перевищення ліміту.
![alt text](.assets/image-5.png)

## 3.4
Напишіть програму, що імітує лотерею, вибираючи 7 різних цілих чисел у діапазоні від 1 до 49 і ще 6 з 36. Встановіть обмеження на час ЦП (max CPU time) і генеруйте результати вибору чисел (7 із 49, 6 із 36). Обробіть ситуацію, коли ліміт ресурсу вичерпано.
![alt text](.assets/image-4.png)

## 3.5 
Напишіть програму для копіювання одного іменованого файлу в інший. Імена файлів передаються у вигляді аргументів.
Перший файл:
![alt text](.assets/image-8.png)
Виконуємо програму:
![alt text](.assets/image-6.png)
Другий файл:
![alt text](.assets/image-7.png)

## 3.6 
Напишіть програму, що демонструє використання обмеження (max stack segment size). Підказка: рекурсивна програма активно використовує стек
![alt text](.assets/image-9.png)
![alt text](.assets/image-10.png)

## 3.7
Встановити обмеження на кількість відкритих сокетів (ulimit -n) та запустити серверну програму.
bash ```ulimit -n 100```
![alt text](.assets/image-11.png)

```
for i in {1..150}; do
  (sleep 10 | telnet 127.0.0.1 8080) &
done
```

![alt text](.assets/image-12.png)

# Практична 4 (pr4)
## Завдання 4.1 (task1.c)
Скільки пам’яті може виділити malloc(3) за один виклик?
Параметр malloc(3) є цілим числом типу даних size_t, тому логічно максимальне число, яке можна передати як параметр malloc(3), — це максимальне значення size_t на платформі (sizeof(size_t)). У 64-бітній Linux size_t становить 8 байтів, тобто 8 * 8 = 64 біти. Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик malloc(3), дорівнює 2^64. Спробуйте запустити код на x86_64 та x86. Чому теоретично максимальний обсяг складає 8 ексабайт, а не 16?
## Завдання 4.2 (task2.c)
Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.
## Завдання 4.3 (task3.c)
Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми.
## Завдання 4.4 (task4.c)
Чи є помилки у такому коді?
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... <використання 'ptr'> ...]
    free(ptr);
}
Напишіть тестовий випадок, який продемонструє проблему та правильний варіант коду.
## Завдання 4.5 (task5.c)
Що станеться, якщо realloc(3) не зможе виділити пам’ять? Напишіть тестовий випадок, що демонструє цей сценарій.
## Завдання 4.6 (task6.c)
Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок.
## Завдання 4.7 (task7.c)
Перепишіть наступний код, використовуючи reallocarray(3):
struct sbar *ptr, *newptr;
ptr = calloc(1000, sizeof(struct sbar));
newptr = realloc(ptr, 500*sizeof(struct sbar));

Порівняйте результати виконання з використанням ltrace.

## Завдання 4.8 (task8.c)
2 Напишіть програму для імітації витоку пам’яті та засічіть її за допомогою valgrind.
![alt text](.assets/image-13.png)

Використання:
```gcc -g -o task8 task8.c```
```sudo apt  install valgrind```
```valgrind --leak-check=full ./task8```



# Практична 5 (pr5)
## 2.Реалізуйте фрагмент коду, який зчитує за межами виділеного масиву без явного порушення доступу — і поясніть, чому це можливо.
![alt text](.assets/imagepr51.png)
![alt text](.assets/imagepr52.png)
## Чому це можливо?
У мові C немає автоматичної перевірки меж масиву — звернення типу arr[3] просто обчислює адресу (arr + 3) без контролю. Це призводить до undefined behavior, але не завжди викликає помилку, бо пам'ять за межами масиву часто належить програмі (наприклад, інша локальна змінна або невикористана область). Помилка з порушенням доступу виникає лише тоді, коли звернення виходить за межі виділеної та захищеної ОС пам'яті.

# Практична 6 (pr6)
## 2.Створіть Dockerfile, що автоматично встановлює Valgrind, компілює програму та запускає її під Valgrind.
![alt text](.assets/imagepr61.png)
![alt text](.assets/imagepr62.png)

Dockerfile — це файл із інструкціями для Docker, що описує, як створити образ.
Команда docker build створює образ на основі Dockerfile.
Команда docker run запускає контейнер із цим образом.

# Практична 7 (pr7)

## Задача 1
Використайте popen(), щоб передати вивід команди rwho (команда UNIX) до more (команда UNIX) у програмі на C. Я використав who замість rwho
![alt text](.assets/1.png)

## Задача 2 
Напишіть програму мовою C, яка імітує команду ls -l в UNIX — виводить список усіх файлів у поточному каталозі та перелічує права доступу тощо. (Варіант вирішення, що просто виконує ls -l із вашої програми, — не підходить.)
![alt text](.assets/2.png)
Програма відкриває поточний каталог, проходить по кожному файлу в ньому, отримує про нього інформацію через stat(), формує рядок з правами доступу, власником, групою, розміром і датою зміни, а потім виводить усе це

## Задача 3
Напишіть програму, яка друкує рядки з файлу, що містять слово, передане як аргумент програми (проста версія утиліти grep в UNIX).
![alt text](.assets/3.png)
Програма читає файл построково і з задопомогою strstr() шукає задане слово

## Задача 4 
Напишіть програму, яка виводить список файлів, заданих у вигляді аргументів, з зупинкою кожні 20 рядків, доки не буде натиснута клавіша (спрощена версія утиліти more в UNIX).
![alt text](.assets/4.png)
Спочатку програма перевіряє аргументи потім по черзі відкриває файли через fopen(), читає їх рядками за допомогою fgets(), виводить по 20 рядків через printf(), чекає Enter за допомогою getchar(), і після завершення закриває файл через fclose()

## Задача 5 
Напишіть програму, яка перелічує всі файли в поточному каталозі та всі файли в підкаталогах.
![alt text](.assets/5.png)
Спочатку програма відкриває каталог за допомогою opendir(), потім по черзі зчитує записи через readdir(), формує повний шлях до кожного файлу через snprintf(), перевіряє, чи це директорія, використовуючи stat(), і якщо це директорія, рекурсивно викликає list() для неї. Якщо це файл, програма виводить його шлях через printf(), а після завершення закриває каталог через closedir()

## Задача 6 
Напишіть програму, яка перелічує лише підкаталоги у алфавітному порядку.

## Задача 7
Напишіть програму, яка показує користувачу всі його/її вихідні програми на C, а потім в інтерактивному режимі запитує, чи потрібно надати іншим дозвіл на читання (read permission); у разі ствердної відповіді — такий дозвіл повинен бути наданий.
![alt text](.assets/6.png)
Спочатку програма відкриває поточний каталог через opendir(). Потім вона по черзі зчитує кожен файл в каталозі через readdir(). Якщо ім'я файлу .c, програма виводить його назву на екран за допомогою . Далі програма запитує у користувача чи потрібно надати дозвіл на читання для цього файлу через . Якщо користувач відповідає "y" або "Y", програма перевіряє наявність файла за допомогою stat(). Якщо файл існує, програма змінює його права доступу за допомогою chmod() і надає дозвіл на читання.

## Задача 8 
Напишіть програму, яка надає користувачу можливість видалити будь-який або всі файли у поточному робочому каталозі. Має з’являтися ім’я файлу з запитом, чи слід його видалити.
![alt text](.assets/7.png)
Спочатку програма відкриває поточний каталог за допомогою opendir(). Потім по черзі зчитує файли через readdir(). Для кожного знайденого файлу програма запитує у користувача, чи потрібно видалити цей файл через . Якщо відповідь (y або Y), програма видаляє файл за допомогою функції remove().

## Задача 9
Напишіть програму на C, яка вимірює час виконання фрагмента коду в мілісекундах.
![alt text](.assets/8.png)

## Задача 10
Напишіть програму мовою C для створення послідовності випадкових чисел з плаваючою комою у діапазонах: (a) від 0.0 до 1.0 (b) від 0.0 до n, де n — будь-яке дійсне число з плаваючою точкою. Початкове значення генератора випадкових чисел має бути встановлене так, щоб гарантувати унікальну послідовність. Примітка: використання прапорця -Wall під час компіляції є обов’язковим.
![alt text](.assets/9.png)
Спочатку програма ініціалізує генератор випадкових чисел через srand(). Потім вона генерує випадкове число в діапазоні від 0.0 до 1.0, ділячи результат функції rand() на максимальне можливе значення RAND_MAX. Після цього програма запитує значення числа n, а потім генерує випадкове число в діапазоні від 0.0 до n, множачи випадкове число в діапазоні від 0.0 до 1.0 на n.

## Завдання по варіанту 2
Реалізуйте утиліту командного рядка, яка виводить процеси, запущені лише з нестандартних шеллів, не використовуючи ps, top, htop.
![alt text](.assets/10.png)


# Практична 8
## Завдання 8.1
 Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.
![alt text](.assets/12.png)

Програма намагається записати багато даних у спеціальний канал (pipe), який має обмежену кількість місця, і якщо це місце закінчується, запис відбувається не повністю — write() повертає лише ту кількість байт, яка реально вмістилась.

## Завдання 8.2
 Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.
Буфер буде містити 2, 3, 3, 7:
![alt text](.assets/11.png)

## Завдання 8.3
 Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
 Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

![alt text](.assets/13.png)

## Завдання 8.4
 Виконайте наступну програму на мові програмування С:
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?
![alt text](.assets/14.png)

## Завдання 8.5
2 Реалізуйте інтерпретатор команд, який підтримує черги читання-запису між процесами через pipe, не використовуючи shell.
![alt text](.assets/image-14.png)

Цей код створює два процеси та з'єднує їх через pipe:  
Перший процес виконує ls і записує результат у pipe.  
Другий процес читає з pipe і виконує wc -l, щоб підрахувати кількість рядків.  
Вся логіка еквівалентна команді:  
ls | wc -l  
але реалізована без shell, напряму через pipe, fork, dup2, execlp.




# Практична 9
## Завдання 9.1
 Напишіть програму, яка читає файл /etc/passwd за допомогою команди getent passwd, щоб дізнатись, які облікові записи визначені на вашому комп’ютері.
 Програма повинна визначити, чи є серед них звичайні користувачі (ідентифікатори UID повинні бути більші за 500 або 1000, залежно від вашого дистрибутива), окрім вас.
![alt text](.assets/image-15.png)

Програма спочатку визначає ім’я поточного користувача за допомогою функції getlogin(). Далі вона відкриває вхідний потік для читання результату виконання команди getent passwd через popen(). Зчитуючи дані пострічково через fgets(), вона розбиває кожен рядок на поля за допомогою strtok() з роздільником :, витягує ім’я користувача та його UID. Якщо UID більше або дорівнює 1000 (тобто це звичайний користувач), і ім’я не збігається з поточним користувачем, програма виводить інформацію про такого користувача.

## Завдання 9.2
 Напишіть програму, яка виконує команду cat /etc/shadow від імені адміністратора, хоча запускається від звичайного користувача.
 (Ваша програма повинна робити необхідне, виходячи з того, що конфігурація системи дозволяє отримувати адміністративний доступ за допомогою відповідної команди.)
![alt text](.assets/image-16.png)
## Завдання 9.3
 Напишіть програму, яка від імені root копіює файл, який вона перед цим створила від імені звичайного користувача. Потім вона повинна помістити копію у домашній каталог звичайного користувача.
 Далі, використовуючи звичайний обліковий запис, програма намагається змінити файл і зберегти зміни. Що відбудеться?
 Після цього програма намагається видалити цей файл за допомогою команди rm. Що відбудеться?
![alt text](.assets/image-17.png)
Спочатку програма створює файл від імені звичайного користувача, використовуючи функцію fopen(). Потім за допомогою команди sudo cp, яка виконується через system(), файл копіюється до домашнього каталогу. Далі програма намагається відкрити скопійований файл у режимі дописування (append) через fopen(); якщо це не вдається — виводиться повідомлення про помилку. Після цього виконується спроба видалити файл за допомогою функції remove(). Наприкінці програма повідомляє про успішне завершення дій.

## Завдання 9.4
 Напишіть програму, яка по черзі виконує команди whoami та id, щоб перевірити стан облікового запису користувача, від імені якого вона запущена.
 Є ймовірність, що команда id виведе список різних груп, до яких ви належите. Програма повинна це продемонструвати.
 ![alt text](.assets/image-18.png)

## Завдання 9.5
 Напишіть програму, яка створює тимчасовий файл від імені звичайного користувача. Потім від імені суперкористувача використовує команди chown і chmod, щоб змінити тип володіння та права доступу.
 Програма повинна визначити, в яких випадках вона може виконувати читання та запис файлу, використовуючи свій обліковий запис.
![alt text](.assets/image-19.png)
Спочатку програма створює файл через fopen(), потім змінює власника і права через system() із sudo. Далі вона перевіряє доступ до читання ("r") і допису ("a"), і виводить результат

## Завдання 9.6
 Напишіть програму, яка виконує команду ls -l, щоб переглянути власника і права доступу до файлів у своєму домашньому каталозі, в /usr/bin та в /etc.
 Продемонструйте, як ваша програма намагається обійти різні власники та права доступу користувачів, а також здійснює спроби читання, запису та виконання цих файлів.
![alt text](.assets/image-20.png)

Програма виконує команди ls -l через system() для трьох каталогів. Потім перебирає три файли та за допомогою access() виводить, чи дозволено читання, запис і виконання
## Завдання 9.7
2 Створіть систему, де обмежується доступ до певного файлу лише в певні години. Які інструменти можна використати?
Інструменти, що я використав:  
time.h — для перевірки поточного часу.  

chmod() — для зміни прав доступу.  

stat() — для перевірки прав доступу.  

cron (опціонально для автоматизації на рівні ОС).  

fopen() — для перевірки спроби відкриття файлу.  

![alt text](.assets/image-21.png)

Так як дозолені години в моїй програмі 9-17, я отримав доступ, але оскільки я маю root доступ, то мій режим доступу не залежить від часу.